# 성능 테스트에서 teardown vs cleanup 전략 결정 이슈

---

## 문제 상황

성능 테스트 대상 시스템의 리소스 관리 정책상 테스트 대상 리소스는 **항상 초기 상태(삭제된 상태)**를 유지해야 함.

- 기존에는 생성된 리소스를 유지한 채 조회/수정/삭제가 가능했으나 정책 변경 이후 더 이상 단일 테스트 흐름으로 유지가 불가능해짐
- 리소스 간 의존성이 강하여 테스트마다 **순차 생성 / 역순 삭제**를 반복해야 하는 구조
- 이를 위해 리소스별로 setup/teardown 또는 fixture를 구성함

그러나 테스트를 반복 실행하는 과정에서 **리소스 정리가 항상 보장되지 않는 문제**를 발견함.

---

## 문제 발생 조건

### 1. teardown 기반 정리의 한계

- 성능 테스트(JMeter)는 실패 가능성이 높은 테스트
- 오류 발생 시:
  - tearDown Thread Group이 실행되지 않거나
  - 스크립트 중단으로 정리 로직이 누락될 수 있음
- 즉, teardown은 **“실행되면 좋은 로직”이지 “반드시 실행되는 보장 수단”이 아님**

### 2. 리소스 의존성 문제

- 상위 리소스가 하위 리소스보다 먼저 삭제될 경우 삭제 실패 또는 orphan 리소스 발생
- thread index 기반으로 리소스 ID를 관리할 경우 반복 실행이나 예외 상황에서 순서가 깨질 가능성 존재

### 3. CI 환경 특성

- CI 환경(Jenkins)에서는
  - 테스트 실패 시 즉시 파이프라인이 중단될 수 있음
  - teardown 실행 여부를 신뢰하기 어려움
- 성능 테스트 결과와 무관하게 **리소스 정리는 반드시 보장되어야 하는 요구사항**이 존재

---

## 해결 전 접근 (시도)

### 1. JMeter tearDown Thread Group 기반 정리

**의도**
- 테스트 종료 시 tearDown에서 생성된 리소스를 삭제
- 성능 테스트 스크립트 내부에서 정리까지 완료하려는 접근

**문제점**
- 테스트 실패 시 tearDown 실행 보장 불가
- CI 환경에서는 삭제 누락 발생 가능성 큼
- 리소스 정리가 테스트 성공 여부에 종속됨

---

### 2. Groovy 기반 정리 로직 개선 논의

**기여 내용**
- 단순 thread 번호 기준 ID 저장 방식의 문제 인식
- JMeter 전역 카운터를 두고 생성된 리소스 ID를 **순서대로 누적 저장**하도록 구조 개선
- tearDown 단계에서 누적된 ID를 기반으로 역순 삭제 설계

**한계**
- 여전히 tearDown 실행 자체가 보장되지 않는 구조
- CI 환경에서는 실패 내성이 부족하다고 판단

---

## 해결 후 전략
### 환경 분리 기반 cleanup 설계

### 전략 결정 기준

- 성능 테스트에서는 **“정리 로직은 테스트 결과와 독립적이어야 한다”**
- teardown은 best-effort 정리 수단, cleanup은 실행 보장을 책임지는 최종 수단인 **guarantee** 관점으로 분리해야 함

---

### 최종 설계

#### 1. 로컬 환경

- 개발 및 디버깅 편의성을 위해 JMeter tearDown 기반 정리 유지
- 테스트 흐름 이해와 빠른 반복 실행에 초점

#### 2. CI 환경 (Jenkins)

- tearDown을 신뢰하지 않음
- Jenkinsfile의 성능 테스트 단계에서 **명시적인 cleanup 로직을 별도로 실행**
- 테스트 성공/실패 여부와 무관하게 리소스 정리 단계가 항상 수행되도록 설계

#### 3. 안전 장치 (`run_all_on_local.sh`)

- JMeter tearDown을 기본 정리 수단으로 사용
- 단, 예외 상황을 대비해 성능 테스트 마지막 단계에 cleanup 함수 추가
- teardown 실패 시에도 리소스 정리 가능하도록 보완

```bash
echo "=== RUN CLEANUP (SAFETY NET) ==="
$PYTHON_CMD performance/cleanup/cleanup_entry.py || true
```

---

## 구현 포인트

- cleanup 로직을 독립 함수로 작성하여 Jenkinsfile, run_all_on_local.sh에서 직접 호출 가능하도록 구성
- 각 JMX 파일에 `BUILD_ID`를 주입하여 생성된 리소스를 실행 단위로 식별
- CI 실행마다 고유한 리소스 그룹을 생성/삭제 가능하도록 설계

---

## 결과 검증

- CI 환경에서 테스트 실패 시에도 리소스가 누락 없이 정리됨을 확인
- 리소스 잔존으로 인해 다음 성능 테스트가 오염되는 문제 제거
- 로컬 / CI 환경 모두에서 성능 테스트 반복 실행 안정성 향상

---

## ✅ 최종 정리

- teardown은 **정리 수단**이지 **정리 보장 수단**이 아님
- 실패 가능성이 높은 성능 테스트에서는 리소스 정리를 테스트 결과와 분리해야 함
- CI 환경에서는 cleanup 로직을 테스트 외부(Jenkinsfile)로 분리하는 것이 안정적
- 자동화 설계에서 중요한 것은 “어디서 정리하느냐”가 아니라 **“삭제가 반드시 보장되는 구조인가”임을 학습**
